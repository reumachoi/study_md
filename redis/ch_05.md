# 레디스를 캐시로 사용하기

## 레디스 for 캐시
### 캐시란
- 원본보다 더 빠르고 액세스 할 수 있는 임시 데이터 저장소

#### 캐시 도입 기대 포인트
- 원본 데이터보다 빠른 조회
- 잘 변하지 않는 데이터를 저장
- 자주 검색되는 데이터를 저장
- 원본 데이터로부터 읽기 커넥션을 줄일 수 있음
- 원본 저장소 장애 발생시 캐시로부터 얻을 수 있음

### 읽기전략
1. look aside
   - 레디스에 캐시 유무 확인 후 존재시 '캐시 히트'로 획득, 미존재시 '캐시 미스'로 원본 DB 접근
   - '캐시 미스'의 경우에만 원본 데이터를 레디스에 저장(lazy loading)
   - 원본 DB로부터 캐시에 데이터를 적재하는 작업을 '캐시 워밍'
     - 많은 트래픽이 발생하기 전, 애플리케이션 시작시, 배치 작업 등을 통해 진행  

### 쓰기전략
- 데이터의 변경사항이 DB에만 업데이트되어 캐시에는 업데이트 되지 않는 '캐시 불일치' 발생
1. write through
    - Redis write -> DB write
      - 다시 사용될 데이터를 쓸 것. 재사용이 불필요한 데이터의 경우 리소스 낭비.
2. cache invalidation
    - DB write -> Redis delete
      - 캐시 무효화(레디스에서 잘못된 데이터를 참조할 경우를 방지)
3. write behind(write back)
   - Redis write -> 추후 DB write
   - 특정 건수나 시간 간격 등에 따라 비동기적으로 DB 업데이트
     - 쓰기가 빈번한 경우 추천
     - 데이터의 실시간 정확도가 중요하지 않아도 되는 경우 추천
     - 캐시 장애 발생시 데이터가 유실될 가능성 존재

### 데이터 관리
- 원본 데이터의 '서브셋'으로 임시 사용처이며, 데이터의 양을 적절히 유지해야 함

#### 만료시간
   - TTL로 데이터 유지시간 설정
     - passive: ttl 만료시에도 자동 삭제되지 않음. 수동삭제.
     - active: ttl 만료시 랜덤하게 추출하여 자동 삭제.
#### 메모리(maxmemory-policy)
   - Noeviction: 데이터가 전부 차더라도 저장불가 에러 반환. 권장하지 않음. 데이터 관리를 애플리케이션에서 해야 함.
   - LRU eviction: 가장 최근에 사용되지 않은 데이터부터 삭제.
     - volatile-lru: 만료시간이 설정된 키에 한해 삭제함. 삭제가 되면 안될 값에 대해는 ttl을 저장하지 않는 전략도 가능.
     - allkeys-lru: 권장방식. LRU 알고리즘으로 데이터 삭제.
   - LFU eviction: 가장 자주 사용되지 않은 데이터부터 삭제. 액세스 패턴에 따라 우선순위 유동변경. 과거 사용량 영향.
     - volatile-lfu: 만료시간이 설정된 키에 한해 삭제함. 삭제가 되면 안될 값에 대해는 ttl을 저장하지 않는 전략도 가능.
     - allkeys-lfu: 권장방식. LFU 알고리즘으로 데이터 삭제. 
   - RANDOM eviction: 임의 키 추출 후 삭제.
     - volatile-random: 만료시간 설정된 키에 한해 삭제.
     - allkeys-random: 모든 키에 대해 랜덤 삭제.
   - volatile-ttl: 만료시간이 가장 작은 키 삭제. 삭제 예정 시간이 얼마 남지 않은 키를 미리 삭제.  

(*LRU, LFU 둘다 근사 알고리즘으로 근사치로 구한 데이터를 삭제함)


### 캐시 스탬피드 현상
- 레디스의 저장된 키가 만료 -> 갑자기 많은 요청들로 인해 DB에 중복 읽기가 발생 -> 레디스에 중복 쓰기 발생

#### 해결방법
1. 적절한 만료 시간 설정
   - 반복 접근될 데이터의 경우 너무 짧지 않게 충분한 시간을 설정할 것
2. 만료시간 선 게산
   - 'PER' 알고리즘 등을 사용하여 미리 키의 만료시간과의 차이값을 구함
     - 특정 기준값보다 적게 남았다면 미리 '캐시워밍' 진행

## 레디스 for 세션 스토어
### 세션 스토어의 역할 및 필요성
- 세션: 서비스 사용 클라이언트의 상태 정보
- 필요성
  - 웹서버가 증가하게 되는 경우 서버별 세션 관리가 종속되어 유저 정보 정합성 불일치 문제가 발생
    - sticky session을 사용하여 동일한 서버로만 요청을 보내도록 해야하지만 트래픽 증가시 부하 증가
  - 여러대의 서버가 유저의 세션을 공유할 수 있는 '세션 스토어'가 필요  

-> 'hash' 구조 추천

### 캐시와 세션스토어의 차이
- 캐시: 여러 애플리케이션이 데이터를 함께 사용
- 세션스토어: 애플리케이션과 데이터 1:1 매칭
  - 세션 활성화 시에만 레디스에 저장하고, 로그아웃시 DB 영구저장 or 삭제 결정